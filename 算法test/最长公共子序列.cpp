#include <iostream>
using namespace std;
#include<stdio.h>
//最长公共子序列问题,这个序列是无序的，只要有相同的就行了
//有很多问题靠人脑很难想到底，比如汉诺塔问题，所以我们只需要找到规律，然后把重复复杂的问题交给计算机做就行了
//L(x,y)=L(x-1,y-1)+1 相等
//L(x,y)=max(L(x-1,y),L(x,y-1)) 不相等时要给L(x,y)一个值，只用从已有的值中去取，像背包问题一样谁大取谁，一层一层来的，前面都是已经算好的对的
//就像递归一样，不用管前面的到底怎么算的，你知道是这样就对了
int main()
{
    int L[8][8];//定义一个数组作为表格进行填写
    char A[8]={'0','x','z','y','z','z','y','x'};
    char B[8]={'0','z','x','y','y','z','x','x'};
    int s[8][8];
    //初始化
    for(int i=0;i<8;i++)
        L[0][i]=0;
    for(int i=0;i<8;i++)
        L[i][0]=0;
    for(int i=1;i<8;i++)
        for(int j=1;j<8;j++)
    {
        //动态规划填表是要一行一行的填的，千万不能跳,而且这一行A只出一个元素，B中检测出了所有与A第一个元素相等的元素
        //动态规划是一种十分精妙的算法，虽然有点难想
        //动态规划的要点
        //1.基式子，也就是表格的某一列或者某一行的值，其他格子从这个基式子得出 2.递推函数 F(n)跟f(n-1)的关系
        //选出两个变量作为表格的行列，比如背包问题的前n个和总容量，这个问题的第一个式子个数，第二个式子个数，找出关系
        if(A[i]==B[j])
        {
           L[i][j]=L[i-1][j-1]+1;
           //对相等的地方进行记录
           s[i][j]=1;
        }
        //不相等时
        else if(L[i-1][j]>=L[i][j-1])
        {
            L[i][j]=L[i-1][j];
            s[i][j]=2;
            //这样可以排序但是找不出最长序列
            //L[i][j]=L[i-1][j]>L[i][j-1]?L[i-1][j]:L[i][j-1];
        }
        else
        {
            L[i][j]=L[i][j-1];
            s[i][j]=3;
            }
    }

    //L[7][7]百分百是最大的数，也就是最大子序列的长度而已，因为L[6][6]才是真正的解
   int i=7;
   int j=7;
   int k=L[7][7];
   char z[100];
   cout<<"k为"<<k<<endl;
   while(i>0&j>0)
	   if(s[i][j]==1)
	   {
		   z[k]=A[i];
		   cout<<z[k];
		   k--;
		   i--;
		   j--;
	   }
	else if(s[i][j]==2)
		i--;
		else
			j--;
    return 0;
}


